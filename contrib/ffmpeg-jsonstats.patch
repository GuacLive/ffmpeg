From 3cc69c7b05ef1dfa256e12dcb354f83313a93c75 Mon Sep 17 00:00:00 2001
From: Ingo Oppermann <ingo@datarhei.com>
Date: Fri, 23 Aug 2024 17:25:02 +0200
Subject: [PATCH v30] JSON progress report (ffmpeg 7.0)

---
 README.PROGRESS.md      | 583 +++++++++++++++++++++++++++++++++++++
 fftools/Makefile        |   1 +
 fftools/ffmpeg.c        |  35 ++-
 fftools/ffmpeg.h        |   1 +
 fftools/ffmpeg_demux.c  | 146 +++-------
 fftools/ffmpeg_demux.h  | 160 +++++++++++
 fftools/ffmpeg_filter.c |   6 +
 fftools/ffmpeg_json.c   | 624 ++++++++++++++++++++++++++++++++++++++++
 fftools/ffmpeg_json.h   |  16 ++
 fftools/ffmpeg_mux.c    |  50 +++-
 fftools/ffmpeg_mux.h    |  19 +-
 fftools/ffmpeg_opt.c    |   7 +
 12 files changed, 1538 insertions(+), 110 deletions(-)
 create mode 100644 README.PROGRESS.md
 create mode 100644 fftools/ffmpeg_demux.h
 create mode 100644 fftools/ffmpeg_json.c
 create mode 100644 fftools/ffmpeg_json.h

diff --git a/README.PROGRESS.md b/README.PROGRESS.md
new file mode 100644
index 00000000..f5e703fa
--- /dev/null
+++ b/README.PROGRESS.md
@@ -0,0 +1,583 @@
+# Progress
+
+Detailed input, mapping, output, and progress outputs as JSON.
+
+Instead of parsing the standard FFmpeg output in order to figure out what streams are available, how they get transformed to the outputs, and what the current
+progress is, this patch prints these information in a structured JSON. Each JSON is prefixed:
+
+| Prefix           | Description                                             |
+| ---------------- | ------------------------------------------------------- |
+| ffmpeg.inputs:   | The list of inputs                                      |
+| ffmpeg.mapping:  | The filter graph and the mapping from inputs to outputs |
+| ffmpeg.outputs:  | The list of outputs                                     |
+| ffmpeg.progress: | The current progress for each input and output          |
+
+## Examples
+
+First we have to create some example files in order demonstrate the output.
+
+`ffmpeg -f lavfi -i testsrc2=rate=25:size=640x360 -map 0:0 -codec:v libx264 -preset:v ultrafast -r 25 -pix_fmt yuv420p -g 50 -f mp4 -t 10 example_noaudio.mp4`
+
+`ffmpeg -f lavfi -i testsrc2=rate=25:size=640x360 -f lavfi -i anullsrc=r=44100:cl=stereo -map 0:0 -map 1:0 -codec:v libx264 -preset:v ultrafast -r 25 -pix_fmt yuv420p -g 50 -codec:a aac -f mp4 -t 10 example_audio.mp4`
+
+`ffmpeg -f lavfi -i testsrc2=rate=25:size=640x360 -map 0:0 -vframes 1 -f image2 -update 1 example.jpg`
+
+No we can see, what will be the different JSON outputs.
+
+### Probe
+
+If no outputs are given, only the inputs will get printed `ffmpeg -i example_audio.mp4`:
+
+`ffmpeg.inputs:[{"url":"example_audio.mp4","format":"mov,mp4,m4a,3gp,3g2,mj2","index":0,"stream":0,"type":"video","codec":"h264","coder":"h264","bitrate_kbps":1822,"duration_sec":10.005000,"language":"und","profile":578,"level":30,"fps":25.000000,"pix_fmt":"yuv420p","width":640,"height":360},{"url":"example_audio.mp4","format":"mov,mp4,m4a,3gp,3g2,mj2","index":0,"stream":1,"type":"audio","codec":"aac","coder":"aac","bitrate_kbps":2,"duration_sec":10.005000,"language":"und","profile":1,"level":-99,"sampling_hz":44100,"layout":"stereo","channels":2}]`
+
+### Stream mapping
+
+With outputs, the stream mapping will get printed.
+
+`ffmpeg -i example_audio.mp4 -f null -`
+
+```json
+{
+    "graphs": [],
+    "mapping": [
+        {
+            "input": {
+                "index": 0,
+                "stream": 0
+            },
+            "output": {
+                "index": 0,
+                "stream": 0
+            },
+            "copy": false
+        },
+        {
+            "input": {
+                "index": 0,
+                "stream": 1
+            },
+            "output": {
+                "index": 0,
+                "stream": 1
+            },
+            "copy": false
+        }
+    ]
+}
+```
+
+`ffmpeg -i example_audio.mp4 -codec copy -f null - `
+
+```json
+{
+    "graphs": [],
+    "mapping": [
+        { "input": { "index": 0, "stream": 0 }, "output": { "index": 0, "stream": 0 }, "copy": true },
+        { "input": { "index": 0, "stream": 1 }, "output": { "index": 0, "stream": 1 }, "copy": true }
+    ]
+}
+```
+
+`ffmpeg -i example_audio.mp4 -codec:v mpeg4 -codec:a copy -f null - `
+
+```json
+{
+    "graphs": [],
+    "mapping": [
+        { "input": { "index": 0, "stream": 0 }, "output": { "index": 0, "stream": 0 }, "copy": false },
+        { "input": { "index": 0, "stream": 1 }, "output": { "index": 0, "stream": 1 }, "copy": true }
+    ]
+}
+```
+
+Or a more complex stream mapping with filters:
+
+`ffmpeg -i example_audio.mp4 -i example.jpg -filter_complex "[0:v]split=2[main][in1];[main]split=2[in2][in3];[in1]boxblur[blur],[blur][1:v]overlay[out1];[in2]negate[out2];[in3]yadif[out3];[out2]split=2[out20][out21]" -map "[out1]" -map "[out3]" -map "[out20]" -map "[out21]" -map 0:a -af "dcshift" -f matroska -y /dev/null`
+
+```json
+{
+    "graphs": [
+        {
+            "index": 0,
+            "graph": [
+                {
+                    "src_id": "600002accc60",
+                    "src_name": "Parsed_split_0",
+                    "src_filter": "split",
+                    "dst_id": "600002accd10",
+                    "dst_name": "Parsed_split_1",
+                    "dst_filter": "split",
+                    "inpad": "output0",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002accc60",
+                    "src_name": "Parsed_split_0",
+                    "src_filter": "split",
+                    "dst_id": "600002accdc0",
+                    "dst_name": "Parsed_boxblur_2",
+                    "dst_filter": "boxblur",
+                    "inpad": "output1",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002accd10",
+                    "src_name": "Parsed_split_1",
+                    "src_filter": "split",
+                    "dst_id": "600002accf20",
+                    "dst_name": "Parsed_negate_4",
+                    "dst_filter": "negate",
+                    "inpad": "output0",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002accd10",
+                    "src_name": "Parsed_split_1",
+                    "src_filter": "split",
+                    "dst_id": "600002accfd0",
+                    "dst_name": "Parsed_yadif_5",
+                    "dst_filter": "yadif",
+                    "inpad": "output1",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002accdc0",
+                    "src_name": "Parsed_boxblur_2",
+                    "src_filter": "boxblur",
+                    "dst_id": "600002acce70",
+                    "dst_name": "Parsed_overlay_3",
+                    "dst_filter": "overlay",
+                    "inpad": "default",
+                    "outpad": "main",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002acce70",
+                    "src_name": "Parsed_overlay_3",
+                    "src_filter": "overlay",
+                    "dst_id": "600002acd3f0",
+                    "dst_name": "format",
+                    "dst_filter": "format",
+                    "inpad": "default",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002accf20",
+                    "src_name": "Parsed_negate_4",
+                    "src_filter": "negate",
+                    "dst_id": "600002acd130",
+                    "dst_name": "Parsed_split_6",
+                    "dst_filter": "split",
+                    "inpad": "default",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002accfd0",
+                    "src_name": "Parsed_yadif_5",
+                    "src_filter": "yadif",
+                    "dst_id": "600002acd550",
+                    "dst_name": "format",
+                    "dst_filter": "format",
+                    "inpad": "default",
+                    "outpad": "default",
+                    "timebase": "1/25600",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002acd130",
+                    "src_name": "Parsed_split_6",
+                    "src_filter": "split",
+                    "dst_id": "600002acd6b0",
+                    "dst_name": "format",
+                    "dst_filter": "format",
+                    "inpad": "output0",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002acd130",
+                    "src_name": "Parsed_split_6",
+                    "src_filter": "split",
+                    "dst_id": "600002acd810",
+                    "dst_name": "format",
+                    "dst_filter": "format",
+                    "inpad": "output1",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002acd1e0",
+                    "src_name": "graph 0 input from stream 0:0",
+                    "src_filter": "buffer",
+                    "dst_id": "600002accc60",
+                    "dst_name": "Parsed_split_0",
+                    "dst_filter": "split",
+                    "inpad": "default",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002acd290",
+                    "src_name": "graph 0 input from stream 1:0",
+                    "src_filter": "buffer",
+                    "dst_id": "600002acd8c0",
+                    "dst_name": "auto_scale_0",
+                    "dst_filter": "scale",
+                    "inpad": "default",
+                    "outpad": "default",
+                    "timebase": "1/25",
+                    "type": "video",
+                    "format": "yuvj420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002acd3f0",
+                    "src_name": "format",
+                    "src_filter": "format",
+                    "dst_id": "600002acd340",
+                    "dst_name": "out_0_0",
+                    "dst_filter": "buffersink",
+                    "inpad": "default",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002acd550",
+                    "src_name": "format",
+                    "src_filter": "format",
+                    "dst_id": "600002acd4a0",
+                    "dst_name": "out_0_1",
+                    "dst_filter": "buffersink",
+                    "inpad": "default",
+                    "outpad": "default",
+                    "timebase": "1/25600",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002acd6b0",
+                    "src_name": "format",
+                    "src_filter": "format",
+                    "dst_id": "600002acd600",
+                    "dst_name": "out_0_2",
+                    "dst_filter": "buffersink",
+                    "inpad": "default",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002acd810",
+                    "src_name": "format",
+                    "src_filter": "format",
+                    "dst_id": "600002acd760",
+                    "dst_name": "out_0_3",
+                    "dst_filter": "buffersink",
+                    "inpad": "default",
+                    "outpad": "default",
+                    "timebase": "1/12800",
+                    "type": "video",
+                    "format": "yuv420p",
+                    "width": 640,
+                    "height": 360
+                },
+                {
+                    "src_id": "600002acd8c0",
+                    "src_name": "auto_scale_0",
+                    "src_filter": "scale",
+                    "dst_id": "600002acce70",
+                    "dst_name": "Parsed_overlay_3",
+                    "dst_filter": "overlay",
+                    "inpad": "default",
+                    "outpad": "overlay",
+                    "timebase": "1/25",
+                    "type": "video",
+                    "format": "yuva420p",
+                    "width": 640,
+                    "height": 360
+                }
+            ]
+        }
+    ],
+    "mapping": [
+        {
+            "input": {
+                "index": 0,
+                "stream": 0
+            },
+            "graph": {
+                "index": 0,
+                "id": "600002acd1e0",
+                "name": "graph 0 input from stream 0:0"
+            },
+            "output": null
+        },
+        {
+            "input": {
+                "index": 1,
+                "stream": 0
+            },
+            "graph": {
+                "index": 0,
+                "id": "600002acd290",
+                "name": "graph 0 input from stream 1:0"
+            },
+            "output": null
+        },
+        {
+            "input": null,
+            "graph": {
+                "index": 0,
+                "id": "600002acd340",
+                "name": "out_0_0"
+            },
+            "output": {
+                "index": 0,
+                "stream": 0
+            }
+        },
+        {
+            "input": null,
+            "graph": {
+                "index": 0,
+                "id": "600002acd4a0",
+                "name": "out_0_1"
+            },
+            "output": {
+                "index": 0,
+                "stream": 1
+            }
+        },
+        {
+            "input": null,
+            "graph": {
+                "index": 0,
+                "id": "600002acd600",
+                "name": "out_0_2"
+            },
+            "output": {
+                "index": 0,
+                "stream": 2
+            }
+        },
+        {
+            "input": null,
+            "graph": {
+                "index": 0,
+                "id": "600002acd760",
+                "name": "out_0_3"
+            },
+            "output": {
+                "index": 0,
+                "stream": 3
+            }
+        },
+        {
+            "input": {
+                "index": 0,
+                "stream": 1
+            },
+            "output": {
+                "index": 0,
+                "stream": 4
+            },
+            "copy": false
+        }
+    ]
+}
+```
+
+### Outputs
+
+```json
+[
+    {
+        "url": "/dev/null",
+        "format": "matroska",
+        "index": 0,
+        "stream": 0,
+        "type": "video",
+        "codec": "h264",
+        "coder": "unknown",
+        "bitrate_kbps": 0,
+        "duration_sec": 0.0,
+        "language": "und",
+        "profile": -99,
+        "level": -99,
+        "fps": 25.0,
+        "pix_fmt": "yuv420p",
+        "width": 640,
+        "height": 360
+    },
+    {
+        "url": "/dev/null",
+        "format": "matroska",
+        "index": 0,
+        "stream": 1,
+        "type": "video",
+        "codec": "h264",
+        "coder": "unknown",
+        "bitrate_kbps": 0,
+        "duration_sec": 0.0,
+        "language": "und",
+        "profile": -99,
+        "level": -99,
+        "fps": 25.0,
+        "pix_fmt": "yuv420p",
+        "width": 640,
+        "height": 360
+    },
+    {
+        "url": "/dev/null",
+        "format": "matroska",
+        "index": 0,
+        "stream": 2,
+        "type": "video",
+        "codec": "h264",
+        "coder": "unknown",
+        "bitrate_kbps": 0,
+        "duration_sec": 0.0,
+        "language": "und",
+        "profile": -99,
+        "level": -99,
+        "fps": 25.0,
+        "pix_fmt": "yuv420p",
+        "width": 640,
+        "height": 360
+    },
+    {
+        "url": "/dev/null",
+        "format": "matroska",
+        "index": 0,
+        "stream": 3,
+        "type": "video",
+        "codec": "h264",
+        "coder": "unknown",
+        "bitrate_kbps": 0,
+        "duration_sec": 0.0,
+        "language": "und",
+        "profile": -99,
+        "level": -99,
+        "fps": 25.0,
+        "pix_fmt": "yuv420p",
+        "width": 640,
+        "height": 360
+    },
+    {
+        "url": "/dev/null",
+        "format": "matroska",
+        "index": 0,
+        "stream": 4,
+        "type": "audio",
+        "codec": "ac3",
+        "coder": "unknown",
+        "bitrate_kbps": 192,
+        "duration_sec": 0.0,
+        "language": "und",
+        "profile": -99,
+        "level": -99,
+        "sampling_hz": 44100,
+        "layout": "stereo",
+        "channels": 2
+    }
+]
+```
+
+### Progress
+
+```json
+{
+    "inputs": [
+        { "index": 0, "stream": 0, "framerate": { "min": 25.0, "max": 25.0, "avg": 25.0 }, "gop": { "min": 50.0, "max": 50.0, "avg": 50.0 }, "frame": 250, "keyframe": 5, "packet": 250, "size_kb": 2225, "size_bytes": 2278562 },
+        { "index": 0, "stream": 1, "framerate": { "min": 43.066, "max": 43.068, "avg": 43.066 }, "gop": { "min": 1.0, "max": 1.0, "avg": 1.0 }, "frame": 432, "keyframe": 432, "packet": 432, "size_kb": 3, "size_bytes": 2622 },
+        { "index": 1, "stream": 0, "framerate": { "min": 0.0, "max": 0.0, "avg": 0.0 }, "gop": { "min": 0.0, "max": 0.0, "avg": 0.0 }, "frame": 1, "keyframe": 1, "packet": 1, "size_kb": 17, "size_bytes": 17150 }
+    ],
+    "outputs": [
+        { "index": 0, "stream": 0, "framerate": { "min": 0.0, "max": 0.0, "avg": 0.0 }, "gop": { "min": 0.0, "max": 0.0, "avg": 0.0 }, "frame": 250, "keyframe": 1, "packet": 250, "q": -1.0, "size_kb": 20, "size_bytes": 20124, "extradata_size_bytes": 0 },
+        {
+            "index": 0,
+            "stream": 1,
+            "framerate": { "min": 0.0, "max": 0.0, "avg": 0.0 },
+            "gop": { "min": 0.0, "max": 0.0, "avg": 0.0 },
+            "frame": 250,
+            "keyframe": 1,
+            "packet": 250,
+            "q": -1.0,
+            "size_kb": 1014,
+            "size_bytes": 1038752,
+            "extradata_size_bytes": 0
+        },
+        { "index": 0, "stream": 2, "framerate": { "min": 0.0, "max": 0.0, "avg": 0.0 }, "gop": { "min": 0.0, "max": 0.0, "avg": 0.0 }, "frame": 250, "keyframe": 1, "packet": 250, "q": -1.0, "size_kb": 882, "size_bytes": 903638, "extradata_size_bytes": 0 },
+        { "index": 0, "stream": 3, "framerate": { "min": 0.0, "max": 0.0, "avg": 0.0 }, "gop": { "min": 0.0, "max": 0.0, "avg": 0.0 }, "frame": 250, "keyframe": 1, "packet": 250, "q": -1.0, "size_kb": 882, "size_bytes": 903638, "extradata_size_bytes": 0 },
+        { "index": 0, "stream": 4, "framerate": { "min": 28.571, "max": 29.412, "avg": 28.715 }, "gop": { "min": 1.0, "max": 1.0, "avg": 1.0 }, "frame": 288, "keyframe": 288, "packet": 288, "size_kb": 235, "size_bytes": 240744, "extradata_size_bytes": 0 }
+    ],
+    "frame": 250,
+    "packet": 250,
+    "q": -1.0,
+    "size_kb": 3034,
+    "size_bytes": 3106896,
+    "time": "0h0m9.92s",
+    "speed": 15.9,
+    "dup": 0,
+    "drop": 0
+}
+```
diff --git a/fftools/Makefile b/fftools/Makefile
index 083a1368..adbf81ee 100644
--- a/fftools/Makefile
+++ b/fftools/Makefile
@@ -19,6 +19,7 @@ OBJS-ffmpeg +=                  \
     fftools/ffmpeg_mux_init.o   \
     fftools/ffmpeg_opt.o        \
     fftools/ffmpeg_sched.o      \
+    fftools/ffmpeg_json.o       \
     fftools/objpool.o           \
     fftools/sync_queue.o        \
     fftools/thread_queue.o      \
diff --git a/fftools/ffmpeg.c b/fftools/ffmpeg.c
index d4e5f978..bc5df866 100644
--- a/fftools/ffmpeg.c
+++ b/fftools/ffmpeg.c
@@ -99,8 +99,11 @@
 
 #include "cmdutils.h"
 #include "ffmpeg.h"
+#include "ffmpeg_demux.h"
+#include "ffmpeg_mux.h"
 #include "ffmpeg_sched.h"
 #include "ffmpeg_utils.h"
+#include "ffmpeg_json.h"
 #include "sync_queue.h"
 
 const char program_name[] = "ffmpeg";
@@ -535,7 +538,7 @@ void update_benchmark(const char *fmt, ...)
     }
 }
 
-static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time, int64_t pts)
+static void print_default_report(int is_last_report, int64_t timer_start, int64_t cur_time, int64_t pts)
 {
     AVBPrint buf, buf_script;
     int64_t total_size = of_filesize(output_files[0]);
@@ -685,6 +688,18 @@ static void print_report(int is_last_report, int64_t timer_start, int64_t cur_ti
     first_report = 0;
 }
 
+static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time, int64_t pts)
+{
+    if(!print_stats && !print_jsonstats && !is_last_report && !progress_avio)
+        return;
+
+    if(print_jsonstats == 1) {
+        print_json_report(is_last_report, timer_start, cur_time, pts);
+    } else {
+        print_default_report(is_last_report, timer_start, cur_time, pts);
+    }
+}
+
 static void print_stream_maps(void)
 {
     av_log(NULL, AV_LOG_INFO, "Stream mapping:\n");
@@ -837,7 +852,7 @@ static int check_keyboard_interaction(int64_t cur_time)
  */
 static int transcode(Scheduler *sch)
 {
-    int ret = 0;
+    int ret = 0, once = 0;
     int64_t timer_start, transcode_ts = 0;
 
     print_stream_maps();
@@ -862,6 +877,14 @@ static int transcode(Scheduler *sch)
             if (check_keyboard_interaction(cur_time) < 0)
                 break;
 
+        // Dump outputs and stream maps before any report
+        if (once == 0 && nb_output_dumped >= nb_output_files) {
+            print_json_stream_maps();
+            print_json_outputs();
+
+            once = 1;
+        }
+
         /* dump report by using the output first video and audio streams */
         print_report(0, timer_start, cur_time, transcode_ts);
     }
@@ -874,6 +897,12 @@ static int transcode(Scheduler *sch)
         ret = err_merge(ret, err);
     }
 
+    // Dump outputs and stream maps before any report
+    if (once == 0 && nb_output_dumped >= nb_output_files) {
+        print_json_stream_maps();
+        print_json_outputs();
+    }
+
     term_exit();
 
     /* dump report by using the first video and audio streams */
@@ -958,6 +987,8 @@ int main(int argc, char **argv)
     if (ret < 0)
         goto finish;
 
+    print_json_inputs();
+
     if (nb_output_files <= 0 && nb_input_files == 0) {
         show_usage();
         av_log(NULL, AV_LOG_WARNING, "Use -h to get full help or, even better, run 'man %s'\n", program_name);
diff --git a/fftools/ffmpeg.h b/fftools/ffmpeg.h
index 6394cca1..83f7214a 100644
--- a/fftools/ffmpeg.h
+++ b/fftools/ffmpeg.h
@@ -643,6 +643,7 @@ extern int debug_ts;
 extern int exit_on_error;
 extern int abort_on_flags;
 extern int print_stats;
+extern int print_jsonstats;
 extern int64_t stats_period;
 extern int stdin_interaction;
 extern AVIOContext *progress_avio;
diff --git a/fftools/ffmpeg_demux.c b/fftools/ffmpeg_demux.c
index 47312c9f..130ade58 100644
--- a/fftools/ffmpeg_demux.c
+++ b/fftools/ffmpeg_demux.c
@@ -20,6 +20,7 @@
 #include <stdint.h>
 
 #include "ffmpeg.h"
+#include "ffmpeg_demux.h"
 #include "ffmpeg_sched.h"
 #include "ffmpeg_utils.h"
 
@@ -39,108 +40,7 @@
 
 #include "libavformat/avformat.h"
 
-typedef struct DemuxStream {
-    InputStream              ist;
-
-    // name used for logging
-    char                     log_name[32];
-
-    int                      sch_idx_stream;
-    int                      sch_idx_dec;
-
-    double                   ts_scale;
-
-    /* non zero if the packets must be decoded in 'raw_fifo', see DECODING_FOR_* */
-    int                      decoding_needed;
-#define DECODING_FOR_OST    1
-#define DECODING_FOR_FILTER 2
-
-    /* true if stream data should be discarded */
-    int                      discard;
-
-    // scheduler returned EOF for this stream
-    int                      finished;
-
-    int                      streamcopy_needed;
-    int                      have_sub2video;
-    int                      reinit_filters;
-
-    int                      wrap_correction_done;
-    int                      saw_first_ts;
-    ///< dts of the first packet read for this stream (in AV_TIME_BASE units)
-    int64_t                  first_dts;
-
-    /* predicted dts of the next packet read for this stream or (when there are
-     * several frames in a packet) of the next frame in current packet (in AV_TIME_BASE units) */
-    int64_t                  next_dts;
-    ///< dts of the last packet read for this stream (in AV_TIME_BASE units)
-    int64_t                  dts;
-
-    const AVCodecDescriptor *codec_desc;
-
-    AVDictionary            *decoder_opts;
-    DecoderOpts              dec_opts;
-    char                     dec_name[16];
-    // decoded media properties, as estimated by opening the decoder
-    AVFrame                 *decoded_params;
-
-    AVBSFContext            *bsf;
-
-    /* number of packets successfully read for this stream */
-    uint64_t                 nb_packets;
-    // combined size of all the packets read
-    uint64_t                 data_size;
-} DemuxStream;
-
-typedef struct Demuxer {
-    InputFile             f;
-
-    // name used for logging
-    char                  log_name[32];
-
-    int64_t               wallclock_start;
-
-    /**
-     * Extra timestamp offset added by discontinuity handling.
-     */
-    int64_t               ts_offset_discont;
-    int64_t               last_ts;
-
-    int64_t               recording_time;
-    int                   accurate_seek;
-
-    /* number of times input stream should be looped */
-    int                   loop;
-    int                   have_audio_dec;
-    /* duration of the looped segment of the input file */
-    Timestamp             duration;
-    /* pts with the smallest/largest values ever seen */
-    Timestamp             min_pts;
-    Timestamp             max_pts;
-
-    /* number of streams that the user was warned of */
-    int                   nb_streams_warn;
-
-    float                 readrate;
-    double                readrate_initial_burst;
-
-    Scheduler            *sch;
-
-    AVPacket             *pkt_heartbeat;
-
-    int                   read_started;
-    int                   nb_streams_used;
-    int                   nb_streams_finished;
-} Demuxer;
-
-typedef struct DemuxThreadContext {
-    // packet used for reading from the demuxer
-    AVPacket *pkt_demux;
-    // packet for reading from BSFs
-    AVPacket *pkt_bsf;
-} DemuxThreadContext;
-
-static DemuxStream *ds_from_ist(InputStream *ist)
+DemuxStream *ds_from_ist(InputStream *ist)
 {
     return (DemuxStream*)ist;
 }
@@ -469,6 +369,48 @@ static int input_packet_process(Demuxer *d, AVPacket *pkt, unsigned *send_flags)
     ds->data_size += pkt->size;
     ds->nb_packets++;
 
+    if(pkt->flags & AV_PKT_FLAG_KEY || ist->par->codec_id == AV_CODEC_ID_WRAPPED_AVFRAME) {
+        ds->nb_keyframes++;
+
+        if (pkt->dts != AV_NOPTS_VALUE) {
+            int64_t ts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);
+
+            // fps estimation
+            if(ts - ds->last_keyframe_dts > 0) {
+                double framerate = (ds->nb_packets - ds->last_keyframe_pktnb) / (double)(ts - ds->last_keyframe_dts) * (double)AV_TIME_BASE;
+                double gopsize = (double)(ds->nb_packets - ds->last_keyframe_pktnb);
+
+                if(ds->min_framerate == 0.0 || framerate < ds->min_framerate) {
+                    ds->min_framerate = framerate;
+                }
+
+                if(ds->max_framerate == 0.0 || framerate > ds->max_framerate) {
+                    ds->max_framerate = framerate;
+                }
+
+                ds->sum_framerate += framerate;
+
+                if(ds->min_gopsize == 0.0 || gopsize < ds->min_gopsize) {
+                    ds->min_gopsize = gopsize;
+                }
+
+                if(ds->max_gopsize == 0.0 || gopsize > ds->max_gopsize) {
+                    ds->max_gopsize = gopsize;
+                }
+
+                ds->sum_gopsize += gopsize;
+
+                ds->nsamples_average++;
+
+                ds->avg_framerate = ((ds->nsamples_average-1)*ds->avg_framerate + framerate) / (double)ds->nsamples_average;
+                ds->avg_gopsize = ((ds->nsamples_average-1)*ds->avg_gopsize + gopsize) / (double)ds->nsamples_average;
+            }
+
+            ds->last_keyframe_dts = ts;
+            ds->last_keyframe_pktnb = ds->nb_packets;
+        }
+    }
+
     fd->wallclock[LATENCY_PROBE_DEMUX] = av_gettime_relative();
 
     if (debug_ts) {
diff --git a/fftools/ffmpeg_demux.h b/fftools/ffmpeg_demux.h
new file mode 100644
index 00000000..08c8fc9d
--- /dev/null
+++ b/fftools/ffmpeg_demux.h
@@ -0,0 +1,160 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFTOOLS_FFMPEG_DEMUX_H
+#define FFTOOLS_FFMPEG_DEMUX_H
+
+#include <float.h>
+#include <stdint.h>
+
+#include "ffmpeg.h"
+#include "ffmpeg_sched.h"
+
+#include "libavutil/avassert.h"
+#include "libavutil/avstring.h"
+#include "libavutil/display.h"
+#include "libavutil/error.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/opt.h"
+#include "libavutil/parseutils.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/time.h"
+#include "libavutil/timestamp.h"
+#include "libavutil/thread.h"
+#include "libavutil/threadmessage.h"
+
+#include "libavcodec/packet.h"
+
+#include "libavformat/avformat.h"
+
+typedef struct DemuxStream {
+    InputStream              ist;
+
+    // name used for logging
+    char                     log_name[32];
+
+    int                      sch_idx_stream;
+    int                      sch_idx_dec;
+
+    double                   ts_scale;
+
+    /* non zero if the packets must be decoded in 'raw_fifo', see DECODING_FOR_* */
+    int                      decoding_needed;
+#define DECODING_FOR_OST    1
+#define DECODING_FOR_FILTER 2
+
+    /* true if stream data should be discarded */
+    int                      discard;
+
+    // scheduler returned EOF for this stream
+    int                      finished;
+
+    int                      streamcopy_needed;
+    int                      have_sub2video;
+    int                      reinit_filters;
+
+    int                      wrap_correction_done;
+    int                      saw_first_ts;
+    ///< dts of the first packet read for this stream (in AV_TIME_BASE units)
+    int64_t                  first_dts;
+
+    /* predicted dts of the next packet read for this stream or (when there are
+     * several frames in a packet) of the next frame in current packet (in AV_TIME_BASE units) */
+    int64_t                  next_dts;
+    ///< dts of the last packet read for this stream (in AV_TIME_BASE units)
+    int64_t                  dts;
+
+    const AVCodecDescriptor *codec_desc;
+
+    AVDictionary            *decoder_opts;
+    DecoderOpts              dec_opts;
+    char                     dec_name[16];
+    // decoded media properties, as estimated by opening the decoder
+    AVFrame                 *decoded_params;
+
+    AVBSFContext            *bsf;
+
+    /* number of packets successfully read for this stream */
+    uint64_t                 nb_packets;
+    // combined size of all the packets read
+    uint64_t                 data_size;
+
+    uint64_t nb_keyframes;
+    int64_t last_keyframe_dts;
+    int64_t last_keyframe_pktnb;
+    int64_t nsamples_average;
+    double sum_framerate, min_framerate, max_framerate, avg_framerate;
+    double sum_gopsize, min_gopsize, max_gopsize, avg_gopsize;
+} DemuxStream;
+
+typedef struct Demuxer {
+    InputFile             f;
+
+    // name used for logging
+    char                  log_name[32];
+
+    int64_t               wallclock_start;
+
+    /**
+     * Extra timestamp offset added by discontinuity handling.
+     */
+    int64_t               ts_offset_discont;
+    int64_t               last_ts;
+
+    int64_t               recording_time;
+    int                   accurate_seek;
+
+    /* number of times input stream should be looped */
+    int                   loop;
+    int                   have_audio_dec;
+    /* duration of the looped segment of the input file */
+    Timestamp             duration;
+    /* pts with the smallest/largest values ever seen */
+    Timestamp             min_pts;
+    Timestamp             max_pts;
+
+    /* number of streams that the user was warned of */
+    int                   nb_streams_warn;
+
+    float                 readrate;
+    double                readrate_initial_burst;
+
+    Scheduler            *sch;
+
+    AVPacket             *pkt_heartbeat;
+
+    int                   read_started;
+    int                   nb_streams_used;
+    int                   nb_streams_finished;
+} Demuxer;
+
+typedef struct DemuxThreadContext {
+    // packet used for reading from the demuxer
+    AVPacket *pkt_demux;
+    // packet for reading from BSFs
+    AVPacket *pkt_bsf;
+} DemuxThreadContext;
+
+typedef struct DemuxMsg {
+    AVPacket *pkt;
+    int looping;
+} DemuxMsg;
+
+DemuxStream *ds_from_ist(InputStream *ist);
+
+#endif /* FFTOOLS_FFMPEG_DEMUX_H */
\ No newline at end of file
diff --git a/fftools/ffmpeg_filter.c b/fftools/ffmpeg_filter.c
index 171e47be..d8153be2 100644
--- a/fftools/ffmpeg_filter.c
+++ b/fftools/ffmpeg_filter.c
@@ -45,6 +45,8 @@
 typedef struct FilterGraphPriv {
     FilterGraph      fg;
 
+    AVFilterGraph   *graph;
+
     // name used for logging
     char             log_name[32];
 
@@ -1829,6 +1831,10 @@ static int configure_filtergraph(FilterGraph *fg, FilterGraphThread *fgt)
             goto fail;
     }
 
+    if (fgt->graph != NULL) {
+        fgp->graph = fgt->graph;
+    }
+
     return 0;
 fail:
     cleanup_filtergraph(fg, fgt);
diff --git a/fftools/ffmpeg_json.c b/fftools/ffmpeg_json.c
new file mode 100644
index 00000000..90df3f41
--- /dev/null
+++ b/fftools/ffmpeg_json.c
@@ -0,0 +1,624 @@
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+
+#include "ffmpeg.h"
+#include "ffmpeg_json.h"
+#include "ffmpeg_mux.h"
+#include "ffmpeg_demux.h"
+
+#include "libavutil/bprint.h"
+#include "libavutil/channel_layout.h"
+#include "libavutil/dict.h"
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/pixfmt.h"
+#include "libavformat/avformat.h"
+#include "libavformat/internal.h"
+#include "libavcodec/avcodec.h"
+
+/**
+ * Print all inputs in JSON format
+ */
+void print_json_inputs(void)
+{
+    AVBPrint buf;
+    int i, j;
+
+    if(print_jsonstats != 1) {
+        return;
+    }
+
+    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);
+
+    av_bprintf(&buf, "ffmpeg.inputs:[");
+    for(i = 0; i < nb_input_files; i++) {
+        InputFile *f = input_files[i];
+        AVFormatContext *ctx = f->ctx;
+
+        float duration = 0;
+        if(ctx->duration != AV_NOPTS_VALUE) {
+            duration = (float)(ctx->duration + (ctx->duration <= INT64_MAX - 5000 ? 5000 : 0)) / (float)AV_TIME_BASE;
+        }
+
+        for(j = 0; j < f->nb_streams; j++) {
+            InputStream *ist = f->streams[j];
+            AVStream *st = ist->st;
+            const FFStream *fst = cffstream(st);
+            AVCodecContext *dec = fst->avctx;
+            AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL, 0);
+            char *url = NULL;
+
+            if(av_escape(&url, ctx->url, "\\\"", AV_ESCAPE_MODE_BACKSLASH, AV_UTF8_FLAG_ACCEPT_ALL) < 0) {
+                url = av_strdup("-");
+            }
+
+            av_bprintf(&buf, "{");
+            av_bprintf(&buf,
+                "\"url\":\"%s\",\"format\":\"%s\",\"index\":%d,\"stream\":%d,",
+                url,
+                ctx->iformat->name,
+                ist->file->index,
+                ist->index);
+            av_bprintf(&buf,
+                "\"type\":\"%s\",\"codec\":\"%s\",\"coder\":\"%s\",\"bitrate_kbps\":%" PRId64
+                ",",
+                av_get_media_type_string(st->codecpar->codec_type),
+                avcodec_get_name(st->codecpar->codec_id),
+                avcodec_get_name(st->codecpar->codec_id),
+                dec->bit_rate / 1000);
+            av_bprintf(&buf,
+                "\"duration_sec\":%f,\"language\":\"%s\",\"profile\":%d,\"level\":%d",
+                duration,
+                lang != NULL ? lang->value : "und",
+                st->codecpar->profile, st->codecpar->level);
+
+            av_free(url);
+
+            if(st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
+                float fps = 0;
+                if(st->avg_frame_rate.den && st->avg_frame_rate.num) {
+                    fps = av_q2d(st->avg_frame_rate);
+                }
+
+                av_bprintf(&buf,
+                    ",\"fps\":%f,\"pix_fmt\":\"%s\",\"width\":%d,\"height\":%d",
+                    fps,
+                    st->codecpar->format == AV_PIX_FMT_NONE
+                        ? "none"
+                        : av_get_pix_fmt_name(st->codecpar->format),
+                    st->codecpar->width,
+                    st->codecpar->height);
+            } else if(st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
+                char layout[128];
+
+                av_channel_layout_describe(&st->codecpar->ch_layout, layout, sizeof(layout));
+
+                av_bprintf(&buf,
+                    ",\"sampling_hz\":%d,\"layout\":\"%s\",\"channels\":%d",
+                    st->codecpar->sample_rate,
+                    layout,
+                    st->codecpar->ch_layout.nb_channels);
+            }
+
+            if(i == (nb_input_files - 1) && j == (f->nb_streams - 1)) {
+                av_bprintf(&buf, "}");
+            } else {
+                av_bprintf(&buf, "},");
+            }
+        }
+    }
+
+    av_bprintf(&buf, "]");
+
+    fprintf(stderr, "%s\n", buf.str);
+    fflush(stderr);
+
+    av_bprint_finalize(&buf, NULL);
+}
+
+/**
+ * Print all outputs in JSON format
+ */
+void print_json_outputs(void)
+{
+    AVBPrint buf;
+
+    if(print_jsonstats != 1) {
+        return;
+    }
+
+    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);
+
+    av_bprintf(&buf, "ffmpeg.outputs:[");
+    for (OutputStream *ost = ost_iter(NULL); ost; ost = ost_iter(ost)) {
+        OutputFile *of = output_files[ost->file->index];
+        Muxer *mux = mux_from_of(of);
+        AVFormatContext *ctx = mux->fc;
+        AVStream *st = ost->st;
+        AVCodecParameters *par = st->codecpar;
+        AVDictionaryEntry *lang = av_dict_get(st->metadata, "language", NULL, 0);
+        char *url = NULL;
+
+        if(av_escape(&url,
+               ctx->url,
+               "\\\"",
+               AV_ESCAPE_MODE_BACKSLASH,
+               AV_UTF8_FLAG_ACCEPT_ALL) < 0) {
+            url = av_strdup("-");
+        }
+
+        av_bprintf(&buf, "{");
+        av_bprintf(&buf,
+            "\"url\":\"%s\",\"format\":\"%s\",\"index\":%d,\"stream\":%d,",
+            url,
+            ctx->oformat->name,
+            ost->file->index,
+            ost->index);
+        av_bprintf(&buf,
+            "\"type\":\"%s\",\"codec\":\"%s\",\"coder\":\"%s\",\"bitrate_kbps\":%" PRId64
+            ",",
+            av_get_media_type_string(par->codec_type),
+            avcodec_get_name(par->codec_id),
+            !ost->enc ? "copy" : "unknown",
+            par->bit_rate / 1000);
+        av_bprintf(&buf,
+            "\"duration_sec\":%f,\"language\":\"%s\",\"profile\":%d,\"level\":%d",
+            0.0,
+            lang != NULL ? lang->value : "und",
+            st->codecpar->profile, st->codecpar->level);
+
+        av_free(url);
+
+        if(st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
+            float fps = 0;
+            if(st->avg_frame_rate.den && st->avg_frame_rate.num) {
+                fps = av_q2d(st->avg_frame_rate);
+            }
+
+            av_bprintf(&buf,
+                ",\"fps\":%f,\"pix_fmt\":\"%s\",\"width\":%d,\"height\":%d",
+                fps,
+                st->codecpar->format == AV_PIX_FMT_NONE
+                    ? "none"
+                    : av_get_pix_fmt_name(st->codecpar->format),
+                st->codecpar->width,
+                st->codecpar->height);
+        } else if(st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
+            char layout[128];
+            av_channel_layout_describe(&st->codecpar->ch_layout, layout, sizeof(layout));
+
+            av_bprintf(&buf,
+                ",\"sampling_hz\":%d,\"layout\":\"%s\",\"channels\":%d",
+                st->codecpar->sample_rate,
+                layout,
+                st->codecpar->ch_layout.nb_channels);
+        }
+
+        if(ost_iter(ost) == NULL) {
+            av_bprintf(&buf, "}");
+        } else {
+            av_bprintf(&buf, "},");
+        }
+    }
+
+    av_bprintf(&buf, "]");
+
+    fprintf(stderr, "%s\n", buf.str);
+    fflush(stderr);
+
+    av_bprint_finalize(&buf, NULL);
+
+    return;
+}
+
+/**
+ * Print progress report in JSON format
+ *
+ * @param is_last_report Whether this is the last report
+ * @param timer_start Time when the processing started
+ * @param cur_time Current processing time of the stream
+ */
+void print_json_report(int is_last_report, int64_t timer_start, int64_t cur_time, int64_t pts)
+{
+    AVBPrint buf;
+    uint64_t stream_size, total_size = 0;
+    uint64_t nb_frames_dup = 0, nb_frames_drop = 0;
+    uint64_t first_vid, first_frame_number = 0, first_packet_number = 0;
+    double speed;
+    static int64_t last_time = -1;
+    int hours, mins, secs, us;
+    const char *hours_sign;
+    float t, q;
+    float first_q = -1;
+
+    if(!print_jsonstats && !is_last_report && !progress_avio) {
+        return;
+    }
+
+    if(!is_last_report) {
+        if(last_time == -1) {
+            last_time = cur_time;
+            return;
+        }
+        if((cur_time - last_time) < 500000) {
+            return;
+        }
+        last_time = cur_time;
+    }
+
+    t = (cur_time - timer_start) / 1000000.0;
+
+    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);
+
+    av_bprintf(&buf, "ffmpeg.progress:{");
+    av_bprintf(&buf, "\"inputs\":[");
+
+    for (InputStream *ist = ist_iter(NULL); ist; ist = ist_iter(ist)) {
+        DemuxStream *ds = ds_from_ist(ist);
+
+        av_bprintf(&buf, "{");
+        av_bprintf(&buf, "\"index\":%d,\"stream\":%d,", ist->file->index, ist->index);
+
+        av_bprintf(&buf, "\"framerate\":{\"min\":%.3f,\"max\":%.3f,\"avg\":%.3f},", ds->min_framerate, ds->max_framerate, ds->avg_framerate);
+        av_bprintf(&buf, "\"gop\":{\"min\":%.3f,\"max\":%.3f,\"avg\":%.3f},", ds->min_gopsize, ds->max_gopsize, ds->avg_gopsize);
+
+        av_bprintf(&buf,
+            "\"frame\":%" PRIu64 ",\"keyframe\":%" PRIu64 ",\"packet\":%" PRIu64 ",",
+            ds->nb_packets,
+            ds->nb_keyframes,
+            ds->nb_packets);
+
+        av_bprintf(&buf, "\"size_kb\":%.0f,\"size_bytes\":%" PRIu64, ds->data_size / 1024.0, ds->data_size);
+
+        if(ist_iter(ist) == NULL) {
+            av_bprintf(&buf, "}");
+        } else {
+            av_bprintf(&buf, "},");
+        }
+    }
+
+    av_bprintf(&buf, "],");
+
+    first_vid = 1;
+
+    av_bprintf(&buf, "\"outputs\":[");
+    for (OutputStream *ost = ost_iter(NULL); ost; ost = ost_iter(ost)) {
+        MuxStream *ms = ms_from_ost(ost);
+
+        q = -1;
+        if(ost->enc) {
+            q = ost->quality / (float)FF_QP2LAMBDA;
+        }
+
+        av_bprintf(&buf, "{");
+        av_bprintf(
+            &buf, "\"index\":%d,\"stream\":%d,", ost->file->index, ost->index);
+
+        av_bprintf(&buf, "\"framerate\":{\"min\":%.3f,\"max\":%.3f,\"avg\":%.3f},", ms->min_framerate, ms->max_framerate, ms->avg_framerate);
+        av_bprintf(&buf, "\"gop\":{\"min\":%.3f,\"max\":%.3f,\"avg\":%.3f},", ms->min_gopsize, ms->max_gopsize, ms->avg_gopsize);
+
+        av_bprintf(&buf,
+            "\"frame\":%" PRIu64 ",\"keyframe\":%" PRIu64 ",\"packet\":%" PRIu64 ",",
+            ost->frames_encoded == 0 ? ms->nb_packets
+                                     : ost->frames_encoded,
+            ms->nb_keyframes,
+            ms->nb_packets);
+
+        if(ost->type == AVMEDIA_TYPE_VIDEO) {
+            av_bprintf(&buf, "\"q\":%.1f,", q);
+
+            if(first_vid == 1) {
+                first_frame_number = ost->frames_encoded == 0
+                    ? ms->nb_packets
+                    : ost->frames_encoded;
+                first_packet_number = ms->nb_packets;
+                first_q = q;
+
+                first_vid = 0;
+            }
+        }
+
+        if(ost->filter) {
+            nb_frames_dup  += ost->filter->nb_frames_dup;
+            nb_frames_drop += ost->filter->nb_frames_drop;
+        }
+
+        stream_size = ms->data_size_mux;
+        total_size += stream_size;
+
+        av_bprintf(&buf, "\"size_kb\":%.0f,\"size_bytes\":%" PRIu64 ",", stream_size / 1024.0, stream_size);
+        av_bprintf(&buf, "\"extradata_size_bytes\":%d", 0);
+
+        if(ost_iter(ost) == NULL) {
+            av_bprintf(&buf, "}");
+        } else {
+            av_bprintf(&buf, "},");
+        }
+    }
+
+    av_bprintf(&buf, "],");
+
+    av_bprintf(&buf,
+        "\"frame\":%" PRIu64 ",\"packet\":%" PRIu64 ",\"q\":%.1f,",
+        first_frame_number,
+        first_packet_number,
+        first_q);
+
+    av_bprintf(&buf, "\"size_kb\":%.0f,\"size_bytes\":%" PRIu64 ",", total_size / 1024.0, total_size);
+
+    us    = FFABS64U(pts) % AV_TIME_BASE;
+    secs  = FFABS64U(pts) / AV_TIME_BASE % 60;
+    mins  = FFABS64U(pts) / AV_TIME_BASE / 60 % 60;
+    hours = FFABS64U(pts) / AV_TIME_BASE / 3600;
+    hours_sign = (pts < 0) ? "-" : "";
+
+    speed   = pts != AV_NOPTS_VALUE && t != 0.0 ? (double)pts / AV_TIME_BASE / t : -1;
+
+    if(pts != AV_NOPTS_VALUE) {
+        av_bprintf(&buf,
+            "\"time\":\"%s%dh%dm%d.%ds\",",
+            hours_sign,
+            hours,
+            mins,
+            secs,
+            (100 * us) / AV_TIME_BASE);
+    }
+
+    av_bprintf(&buf, "\"speed\":%.3g,", speed);
+
+    av_bprintf(&buf, "\"dup\":%"PRId64",\"drop\":%"PRId64, nb_frames_dup, nb_frames_drop);
+    av_bprintf(&buf, "}");
+
+    if(print_jsonstats || is_last_report) {
+        fprintf(stderr, "%s\n", buf.str);
+        fflush(stderr);
+    }
+
+    av_bprint_finalize(&buf, NULL);
+}
+
+/**
+ * Write a graph as JSON to an initialized buffer
+ *
+ * @param buf Pointer to an initialized AVBPrint buffer
+ * @param index Index of the graph
+ * @param graph Pointer to a AVFilterGraph
+ */
+void print_json_graph(AVBPrint *buf, int index, AVFilterGraph *graph)
+{
+    int i, j;
+
+    if(graph == NULL) {
+        return;
+    }
+
+    if(graph->nb_filters == 0) {
+        return;
+    }
+
+    av_bprintf(buf, "{\"index\":%d,\"graph\":[", index);
+
+    for(i = 0; i < graph->nb_filters; i++) {
+        const AVFilterContext *filter_ctx = graph->filters[i];
+
+        for(j = 0; j < filter_ctx->nb_outputs; j++) {
+            AVFilterLink *link = filter_ctx->outputs[j];
+            if(link) {
+                const AVFilterContext *dst_filter_ctx = link->dst;
+
+                av_bprintf(buf,
+                    "{\"src_id\":\"%"PRIxPTR"\",\"src_name\":\"%s\",\"src_filter\":\"%s\",\"dst_id\":\"%"PRIxPTR"\",\"dst_name\":\"%s\",\"dst_filter\":\"%s\",",
+                    (uintptr_t)filter_ctx,
+                    filter_ctx->name,
+                    filter_ctx->filter->name,
+                    (uintptr_t)dst_filter_ctx,
+                    dst_filter_ctx->name,
+                    dst_filter_ctx->filter->name);
+                av_bprintf(buf,
+                    "\"inpad\":\"%s\",\"outpad\":\"%s\",",
+                    avfilter_pad_get_name(link->srcpad, 0),
+                    avfilter_pad_get_name(link->dstpad, 0));
+                av_bprintf(buf,
+                    "\"timebase\": \"%d/%d\",",
+                    link->time_base.num,
+                    link->time_base.den);
+
+                if(link->type == AVMEDIA_TYPE_VIDEO) {
+                    const AVPixFmtDescriptor *desc =
+                        av_pix_fmt_desc_get(link->format);
+                    av_bprintf(buf,
+                        "\"type\":\"video\",\"format\":\"%s\",\"width\":%d,\"height\":%d",
+                        desc->name,
+                        link->w,
+                        link->h);
+                } else if(link->type == AVMEDIA_TYPE_AUDIO) {
+                    char layout[255];
+                    av_channel_layout_describe(&link->ch_layout, layout, sizeof(layout));
+                    av_bprintf(buf,
+                        "\"type\":\"audio\",\"format\":\"%s\",\"sampling_hz\":%d,\"layout\":\"%s\"",
+                        av_get_sample_fmt_name(link->format),
+                        link->sample_rate,
+                        layout);
+                }
+
+                if(i == (graph->nb_filters - 1)) {
+                    av_bprintf(buf, "}");
+                } else {
+                    av_bprintf(buf, "},");
+                }
+            }
+        }
+    }
+
+    av_bprintf(buf, "]},");
+}
+
+typedef struct FilterGraphPriv {
+    FilterGraph      fg;
+    AVFilterGraph   *graph;
+} FilterGraphPriv;
+
+static const FilterGraphPriv *cfgp_from_cfg(const FilterGraph *fg)
+{
+    return (const FilterGraphPriv*)fg;
+}
+
+typedef struct InputFilterPriv {
+    InputFilter         ifilter;
+    InputFilterOptions  opts;
+    int                 index;
+    AVFilterContext    *filter;
+} InputFilterPriv;
+
+static InputFilterPriv *ifp_from_ifilter(InputFilter *ifilter)
+{
+    return (InputFilterPriv*)ifilter;
+}
+
+typedef struct OutputFilterPriv {
+    OutputFilter            ofilter;
+    int                     index;
+    AVFilterContext        *filter;
+} OutputFilterPriv;
+
+static OutputFilterPriv *ofp_from_ofilter(OutputFilter *ofilter)
+{
+    return (OutputFilterPriv*)ofilter;
+}
+
+void print_json_stream_maps(void)
+{
+    int i, j;
+    AVBPrint buf;
+
+    if(print_jsonstats != 1) {
+        return;
+    }
+
+    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);
+
+    av_bprintf(&buf, "ffmpeg.mapping:{");
+    av_bprintf(&buf, "\"graphs\":[");
+
+    for(i = 0; i < nb_filtergraphs; i++) {
+        FilterGraph *fg = filtergraphs[i];
+        const FilterGraphPriv *fgp = cfgp_from_cfg(fg);
+
+        print_json_graph(&buf, fg->index, fgp->graph);
+    }
+
+    if(buf.str[buf.len-1] == ',') {
+        buf.str[buf.len-1] = '\0';
+        buf.len--;
+    }
+
+    av_bprintf(&buf, "],");
+
+    // The following is inspired by tools/graph2dot.c
+
+    av_bprintf(&buf, "\"mapping\":[");
+
+    for (InputStream *ist = ist_iter(NULL); ist; ist = ist_iter(ist)) {
+        for(i = 0; i < ist->nb_filters; i++) {
+            InputFilter *f = ist->filters[i];
+            const FilterGraphPriv *fgp = cfgp_from_cfg(f->graph);
+
+            if (fgp->graph->nb_filters != 0) {
+                InputFilterPriv *ifp = ifp_from_ifilter(f);
+                AVFilterContext *ctx = ifp->filter;
+
+                av_bprintf(&buf,
+                    "{\"input\":{\"index\":%d,\"stream\":%d},\"graph\":{\"index\":%d,\"id\":\"%"PRIxPTR"\",\"name\":\"%s\"},\"output\":null},",
+                    ist->file->index,
+                    ist->st->index,
+                    f->graph->index,
+                    (uintptr_t)ctx,
+                    ctx->name);
+            }
+        }
+    }
+
+    for(i = 0; i < nb_filtergraphs; i++) {
+        FilterGraph *fg = filtergraphs[i];
+        const FilterGraphPriv *fgp = cfgp_from_cfg(fg);
+
+        if(fgp->graph->nb_filters == 0) {
+            continue;
+        }
+
+        for(j = 0; j < fg->nb_outputs; j++) {
+            OutputFilter *of = fg->outputs[j];
+            OutputStream *ost = of->ost;
+            OutputFilterPriv *ofp = ofp_from_ofilter(of);
+            AVFilterContext *ctx = ofp->filter;
+
+            av_bprintf(&buf,
+                "{\"input\":null,\"graph\":{\"index\":%d,\"id\":\"%"PRIxPTR"\",\"name\":\"%s\"},\"output\":{\"index\":%d,\"stream\":%d}}",
+                fg->index,
+                (uintptr_t)ctx,
+                ctx->name,
+                ost->file->index,
+                ost->index);
+
+            if(j != (fg->nb_outputs - 1)) {
+                av_bprintf(&buf, ",");
+            }
+        }
+
+        if(i != (nb_filtergraphs - 1)) {
+            av_bprintf(&buf, ",");
+        }
+    }
+
+    for (OutputStream *ost = ost_iter(NULL); ost; ost = ost_iter(ost)) {
+        if(ost->attachment_filename) {
+            av_bprintf(&buf,
+                "{\"input\":null,\"file\":\"%s\",\"output\":{\"index\":%d,\"stream\":%d}},",
+                ost->attachment_filename,
+                ost->file->index,
+                ost->index);
+            continue;
+        }
+
+        if(ost->filter && ost->filter->graph) {
+            FilterGraph *fg = ost->filter->graph;
+            const FilterGraphPriv *fgp = cfgp_from_cfg(fg);
+
+            if(fgp->graph->nb_filters == 0) {
+                av_bprintf(&buf,
+                    "{\"input\":{\"index\":%d,\"stream\":%d},\"output\":{\"index\":%d,\"stream\":%d},\"copy\":%s},",
+                    ost->ist->file->index,
+                    ost->ist->st->index,
+                    ost->file->index,
+                    ost->index,
+                    !ost->enc ? "true" : "false");
+            }
+
+            continue;
+        }
+
+        av_bprintf(&buf,
+            "{\"input\":{\"index\":%d,\"stream\":%d},\"output\":{\"index\":%d,\"stream\":%d},\"copy\":%s},",
+            ost->ist->file->index,
+            ost->ist->st->index,
+            ost->file->index,
+            ost->index,
+            !ost->enc ? "true" : "false");
+    }
+
+    if(buf.str[buf.len-1] == ',') {
+        buf.str[buf.len-1] = '\0';
+        buf.len--;
+    }
+
+    av_bprintf(&buf, "]}");
+
+    fprintf(stderr, "%s\n", buf.str);
+    fflush(stderr);
+
+    av_bprint_finalize(&buf, NULL);
+
+    return;
+}
diff --git a/fftools/ffmpeg_json.h b/fftools/ffmpeg_json.h
new file mode 100644
index 00000000..becf6b7f
--- /dev/null
+++ b/fftools/ffmpeg_json.h
@@ -0,0 +1,16 @@
+#ifndef FFTOOLS_FFMPEG_JSON_H
+#define FFTOOLS_FFMPEG_JSON_H
+
+#include <stdint.h>
+
+#include "ffmpeg.h"
+#include "libavutil/bprint.h"
+#include "libavfilter/avfilter.h"
+
+void print_json_inputs(void);
+void print_json_outputs(void);
+void print_json_report(int is_last_report, int64_t timer_start, int64_t cur_time, int64_t pts);
+void print_json_graph(AVBPrint *buf, int index, AVFilterGraph *graph);
+void print_json_stream_maps(void);
+
+#endif /* FFTOOLS_FFMPEG_JSON_H */
diff --git a/fftools/ffmpeg_mux.c b/fftools/ffmpeg_mux.c
index e8e5c677..a52f14e9 100644
--- a/fftools/ffmpeg_mux.c
+++ b/fftools/ffmpeg_mux.c
@@ -43,7 +43,12 @@ typedef struct MuxThreadContext {
     AVPacket *fix_sub_duration_pkt;
 } MuxThreadContext;
 
-static Muxer *mux_from_of(OutputFile *of)
+MuxStream *ms_from_ost(OutputStream *ost)
+{
+    return (MuxStream*)ost;
+}
+
+Muxer *mux_from_of(OutputFile *of)
 {
     return (Muxer*)of;
 }
@@ -226,8 +231,51 @@ static int write_packet(Muxer *mux, OutputStream *ost, AVPacket *pkt)
         goto fail;
 
     ms->data_size_mux += pkt->size;
+    ms->nb_packets++;
     frame_num = atomic_fetch_add(&ost->packets_written, 1);
 
+    if(pkt->flags & AV_PKT_FLAG_KEY) {
+        ms->nb_keyframes++;
+
+        if (pkt->dts != AV_NOPTS_VALUE) {
+            int64_t ts = av_rescale_q(pkt->dts, ost->st->time_base, AV_TIME_BASE_Q);
+
+            // fps estimation
+            if(ts - ms->last_keyframe_dts > 0) {
+                double framerate = (ms->nb_packets - ms->last_keyframe_pktnb) / (double)(ts - ms->last_keyframe_dts) * (double)AV_TIME_BASE;
+                double gopsize = (double)(ms->nb_packets - ms->last_keyframe_pktnb);
+
+                if(ms->min_framerate == 0.0 || framerate < ms->min_framerate) {
+                    ms->min_framerate = framerate;
+                }
+
+                if(ms->max_framerate == 0.0 || framerate > ms->max_framerate) {
+                    ms->max_framerate = framerate;
+                }
+
+                ms->sum_framerate += framerate;
+
+                if(ms->min_gopsize == 0.0 || gopsize < ms->min_gopsize) {
+                    ms->min_gopsize = gopsize;
+                }
+
+                if(ms->max_gopsize == 0.0 || gopsize > ms->max_gopsize) {
+                    ms->max_gopsize = gopsize;
+                }
+
+                ms->sum_gopsize += gopsize;
+
+                ms->nsamples_average++;
+
+                ms->avg_framerate = ((ms->nsamples_average-1)*ms->avg_framerate + framerate) / (double)ms->nsamples_average;
+                ms->avg_gopsize = ((ms->nsamples_average-1)*ms->avg_gopsize + gopsize) / (double)ms->nsamples_average;
+            }
+
+            ms->last_keyframe_dts = ts;
+            ms->last_keyframe_pktnb = ms->nb_packets;
+        }
+    }
+
     pkt->stream_index = ost->index;
 
     if (ms->stats.io)
diff --git a/fftools/ffmpeg_mux.h b/fftools/ffmpeg_mux.h
index 16af6d38..a4f8ecb3 100644
--- a/fftools/ffmpeg_mux.h
+++ b/fftools/ffmpeg_mux.h
@@ -75,6 +75,18 @@ typedef struct MuxStream {
     int             copy_initial_nonkeyframes;
     int             copy_prior_start;
     int             streamcopy_started;
+
+    uint64_t        nb_packets;
+    uint64_t        nb_keyframes;
+    // number of frames/samples sent to the encoder
+    uint64_t        frames_encoded;
+    uint64_t        samples_encoded;
+
+    int64_t         last_keyframe_dts;
+    int64_t         last_keyframe_pktnb;
+    int64_t         nsamples_average;
+    double          sum_framerate, min_framerate, max_framerate, avg_framerate;
+    double          sum_gopsize, min_gopsize, max_gopsize, avg_gopsize;
 } MuxStream;
 
 typedef struct Muxer {
@@ -104,10 +116,7 @@ typedef struct Muxer {
 } Muxer;
 
 int mux_check_init(void *arg);
-
-static MuxStream *ms_from_ost(OutputStream *ost)
-{
-    return (MuxStream*)ost;
-}
+MuxStream *ms_from_ost(OutputStream *ost);
+Muxer *mux_from_of(OutputFile *of);
 
 #endif /* FFTOOLS_FFMPEG_MUX_H */
diff --git a/fftools/ffmpeg_opt.c b/fftools/ffmpeg_opt.c
index 4b3f9789..544bd29d 100644
--- a/fftools/ffmpeg_opt.c
+++ b/fftools/ffmpeg_opt.c
@@ -28,7 +28,9 @@
 #endif
 
 #include "ffmpeg.h"
+#include "ffmpeg_mux.h"
 #include "ffmpeg_sched.h"
+#include "ffmpeg_json.h"
 #include "cmdutils.h"
 #include "opt_common.h"
 #include "sync_queue.h"
@@ -53,6 +55,7 @@
 #include "libavutil/parseutils.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/pixfmt.h"
+#include "libavutil/bprint.h"
 
 HWDevice *filter_hw_device;
 
@@ -77,6 +80,7 @@ int debug_ts          = 0;
 int exit_on_error     = 0;
 int abort_on_flags    = 0;
 int print_stats       = -1;
+int print_jsonstats   = 1;
 int stdin_interaction = 1;
 float max_error_rate  = 2.0/3;
 char *filter_nbthreads;
@@ -1579,6 +1583,9 @@ const OptionDef options[] = {
     { "stats",               OPT_TYPE_BOOL, 0,
         { &print_stats },
         "print progress report during encoding", },
+    { "jsonstats",      OPT_TYPE_BOOL, 0,
+        { &print_jsonstats },
+        "print JSON progress report during encoding", },
     { "stats_period",        OPT_TYPE_FUNC, OPT_FUNC_ARG | OPT_EXPERT,
         { .func_arg = opt_stats_period },
         "set the period at which ffmpeg updates stats and -progress output", "time" },

base-commit: 9f0f680f9ab1ca72edd94de42aef12209c11a6b2
-- 
2.39.3 (Apple Git-146)

