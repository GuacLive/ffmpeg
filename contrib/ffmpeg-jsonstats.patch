From d65f402f0102c34f8411757a118509e3cfbd4012 Mon Sep 17 00:00:00 2001
From: Ingo Oppermann <ingo@datarhei.com>
Date: Wed, 10 Jan 2024 16:06:17 +0100
Subject: [PATCH v27] JSON progress report (ffmpeg 6.1)

---
 fftools/ffmpeg.c       | 198 +++++++++++++++++++++++-
 fftools/ffmpeg.h       |   1 +
 fftools/ffmpeg_demux.c | 118 ++++++---------
 fftools/ffmpeg_demux.h | 121 +++++++++++++++
 fftools/ffmpeg_mux.c   | 337 +++++++++++++++++++++++++++++++++++++++++
 fftools/ffmpeg_mux.h   |  12 ++
 fftools/ffmpeg_opt.c   | 112 ++++++++++++++
 7 files changed, 823 insertions(+), 76 deletions(-)
 create mode 100644 fftools/ffmpeg_demux.h

diff --git a/fftools/ffmpeg.c b/fftools/ffmpeg.c
index 46a85b41..1e4bf21f 100644
--- a/fftools/ffmpeg.c
+++ b/fftools/ffmpeg.c
@@ -99,6 +99,8 @@
 
 #include "cmdutils.h"
 #include "ffmpeg.h"
+#include "ffmpeg_demux.h"
+#include "ffmpeg_mux.h"
 #include "sync_queue.h"
 
 const char program_name[] = "ffmpeg";
@@ -493,7 +495,7 @@ void close_output_stream(OutputStream *ost)
         sq_send(of->sq_encode, ost->sq_idx_encode, SQFRAME(NULL));
 }
 
-static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time)
+static void print_default_report(int is_last_report, int64_t timer_start, int64_t cur_time)
 {
     AVBPrint buf, buf_script;
     int64_t total_size = of_filesize(output_files[0]);
@@ -648,6 +650,200 @@ static void print_report(int is_last_report, int64_t timer_start, int64_t cur_ti
     first_report = 0;
 }
 
+/**
+ * Print progress report in JSON format
+ *
+ * @param is_last_report Whether this is the last report
+ * @param timer_start Time when the processing started
+ * @param cur_time Current processing time of the stream
+ */
+static void print_json_report(int is_last_report, int64_t timer_start, int64_t cur_time)
+{
+    AVBPrint buf;
+    uint64_t stream_size, total_size = 0;
+    AVCodecContext *enc;
+    uint64_t nb_frames_dup = 0, nb_frames_drop = 0;
+    uint64_t first_vid, first_frame_number = 0, first_packet_number = 0;
+    double speed;
+    int64_t pts = AV_NOPTS_VALUE;
+    static int64_t last_time = -1;
+    int hours, mins, secs, us;
+    const char *hours_sign;
+    float t, q;
+    float first_q = -1;
+
+    if(!print_jsonstats && !is_last_report && !progress_avio) {
+        return;
+    }
+
+    if(!is_last_report) {
+        if(last_time == -1) {
+            last_time = cur_time;
+            return;
+        }
+        if((cur_time - last_time) < 500000) {
+            return;
+        }
+        last_time = cur_time;
+    }
+
+    t = (cur_time - timer_start) / 1000000.0;
+
+    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);
+
+    av_bprintf(&buf, "ffmpeg.progress:{");
+    av_bprintf(&buf, "\"inputs\":[");
+
+    for (InputStream *ist = ist_iter(NULL); ist; ist = ist_iter(ist)) {
+        DemuxStream *ds = ds_from_ist(ist);
+
+        av_bprintf(&buf, "{");
+        av_bprintf(&buf, "\"index\":%d,\"stream\":%d,", ist->file_index, ist->index);
+
+        av_bprintf(&buf, "\"framerate\":{\"min\":%.3f,\"max\":%.3f,\"avg\":%.3f},", ds->min_framerate, ds->max_framerate, ds->avg_framerate);
+        av_bprintf(&buf, "\"gop\":{\"min\":%.3f,\"max\":%.3f,\"avg\":%.3f},", ds->min_gopsize, ds->max_gopsize, ds->avg_gopsize);
+
+        av_bprintf(&buf,
+            "\"frame\":%" PRIu64 ",\"keyframe\":%" PRIu64 ",\"packet\":%" PRIu64 ",",
+            ist->frames_decoded == 0 ? ds->nb_packets
+                                        : ist->frames_decoded,
+            ds->nb_keyframes,
+            ds->nb_packets);
+
+        av_bprintf(&buf, "\"size_kb\":%.0f,\"size_bytes\":%" PRIu64, ds->data_size / 1024.0, ds->data_size);
+
+        if(ist_iter(ist) == NULL) {
+            av_bprintf(&buf, "}");
+        } else {
+            av_bprintf(&buf, "},");
+        }
+    }
+
+    av_bprintf(&buf, "],");
+
+    first_vid = 1;
+
+    av_bprintf(&buf, "\"outputs\":[");
+    for (OutputStream *ost = ost_iter(NULL); ost; ost = ost_iter(ost)) {
+        MuxStream *ms = ms_from_ost(ost);
+
+        q = -1;
+        enc = ost->enc_ctx ? ost->enc_ctx : ost->ist->dec_ctx;
+        if(ost->enc) {
+            q = ost->quality / (float)FF_QP2LAMBDA;
+        }
+
+        av_bprintf(&buf, "{");
+        av_bprintf(
+            &buf, "\"index\":%d,\"stream\":%d,", ost->file_index, ost->index);
+
+        av_bprintf(&buf, "\"framerate\":{\"min\":%.3f,\"max\":%.3f,\"avg\":%.3f},", ms->min_framerate, ms->max_framerate, ms->avg_framerate);
+        av_bprintf(&buf, "\"gop\":{\"min\":%.3f,\"max\":%.3f,\"avg\":%.3f},", ms->min_gopsize, ms->max_gopsize, ms->avg_gopsize);
+
+        av_bprintf(&buf,
+            "\"frame\":%" PRIu64 ",\"keyframe\":%" PRIu64 ",\"packet\":%" PRIu64 ",",
+            ost->frames_encoded == 0 ? ms->nb_packets
+                                     : ost->frames_encoded,
+            ms->nb_keyframes,
+            ms->nb_packets);
+
+        if(enc->codec_type == AVMEDIA_TYPE_VIDEO) {
+            av_bprintf(&buf, "\"q\":%.1f,", q);
+
+            if(first_vid == 1) {
+                first_frame_number = ost->frames_encoded == 0
+                    ? ms->nb_packets
+                    : ost->frames_encoded;
+                first_packet_number = ms->nb_packets;
+                first_q = q;
+
+                first_vid = 0;
+            }
+        }
+
+        if(ost->filter) {
+            nb_frames_dup  += ost->filter->nb_frames_dup;
+            nb_frames_drop += ost->filter->nb_frames_drop;
+        }
+
+        /* compute min output value */
+        if (ost->last_mux_dts != AV_NOPTS_VALUE) {
+            if (pts == AV_NOPTS_VALUE || ost->last_mux_dts > pts)
+                pts = ost->last_mux_dts;
+            if (copy_ts) {
+                if (copy_ts_first_pts == AV_NOPTS_VALUE && pts > 1)
+                    copy_ts_first_pts = pts;
+                if (copy_ts_first_pts != AV_NOPTS_VALUE)
+                    pts -= copy_ts_first_pts;
+            }
+        }
+
+        stream_size = ms->data_size_mux;
+        total_size += stream_size;
+
+        av_bprintf(&buf, "\"size_kb\":%.0f,\"size_bytes\":%" PRIu64 ",", stream_size / 1024.0, stream_size);
+        av_bprintf(&buf, "\"extradata_size_bytes\":%d", enc->extradata_size);
+
+        if(ost_iter(ost) == NULL) {
+            av_bprintf(&buf, "}");
+        } else {
+            av_bprintf(&buf, "},");
+        }
+    }
+
+    av_bprintf(&buf, "],");
+
+    av_bprintf(&buf,
+        "\"frame\":%" PRIu64 ",\"packet\":%" PRIu64 ",\"q\":%.1f,",
+        first_frame_number,
+        first_packet_number,
+        first_q);
+
+    av_bprintf(&buf, "\"size_kb\":%.0f,\"size_bytes\":%" PRIu64 ",", total_size / 1024.0, total_size);
+
+    us    = FFABS64U(pts) % AV_TIME_BASE;
+    secs  = FFABS64U(pts) / AV_TIME_BASE % 60;
+    mins  = FFABS64U(pts) / AV_TIME_BASE / 60 % 60;
+    hours = FFABS64U(pts) / AV_TIME_BASE / 3600;
+    hours_sign = (pts < 0) ? "-" : "";
+
+    speed   = pts != AV_NOPTS_VALUE && t != 0.0 ? (double)pts / AV_TIME_BASE / t : -1;
+
+    if(pts != AV_NOPTS_VALUE) {
+        av_bprintf(&buf,
+            "\"time\":\"%s%dh%dm%d.%ds\",",
+            hours_sign,
+            hours,
+            mins,
+            secs,
+            (100 * us) / AV_TIME_BASE);
+    }
+
+    av_bprintf(&buf, "\"speed\":%.3g,", speed);
+
+    av_bprintf(&buf, "\"dup\":%"PRId64",\"drop\":%"PRId64, nb_frames_dup, nb_frames_drop);
+    av_bprintf(&buf, "}");
+
+    if(print_jsonstats || is_last_report) {
+        fprintf(stderr, "%s\n", buf.str);
+        fflush(stderr);
+    }
+
+    av_bprint_finalize(&buf, NULL);
+}
+
+static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time)
+{
+    if(!print_stats && !print_jsonstats && !is_last_report && !progress_avio)
+        return;
+
+    if(print_jsonstats == 1) {
+        print_json_report(is_last_report, timer_start, cur_time);
+    } else {
+        print_default_report(is_last_report, timer_start, cur_time);
+    }
+}
+
 int copy_av_subtitle(AVSubtitle *dst, const AVSubtitle *src)
 {
     int ret = AVERROR_BUG;
diff --git a/fftools/ffmpeg.h b/fftools/ffmpeg.h
index 0983d026..50d0d45f 100644
--- a/fftools/ffmpeg.h
+++ b/fftools/ffmpeg.h
@@ -675,6 +675,7 @@ extern int debug_ts;
 extern int exit_on_error;
 extern int abort_on_flags;
 extern int print_stats;
+extern int print_jsonstats;
 extern int64_t stats_period;
 extern int stdin_interaction;
 extern AVIOContext *progress_avio;
diff --git a/fftools/ffmpeg_demux.c b/fftools/ffmpeg_demux.c
index 350f233a..173fa298 100644
--- a/fftools/ffmpeg_demux.c
+++ b/fftools/ffmpeg_demux.c
@@ -20,6 +20,7 @@
 #include <stdint.h>
 
 #include "ffmpeg.h"
+#include "ffmpeg_demux.h"
 
 #include "libavutil/avassert.h"
 #include "libavutil/avstring.h"
@@ -52,81 +53,6 @@ static const char *const opt_name_display_rotations[]         = {"display_rotati
 static const char *const opt_name_display_hflips[]            = {"display_hflip", NULL};
 static const char *const opt_name_display_vflips[]            = {"display_vflip", NULL};
 
-typedef struct DemuxStream {
-    InputStream ist;
-
-    // name used for logging
-    char log_name[32];
-
-    double ts_scale;
-
-    int streamcopy_needed;
-
-    int wrap_correction_done;
-    int saw_first_ts;
-    ///< dts of the first packet read for this stream (in AV_TIME_BASE units)
-    int64_t first_dts;
-
-    /* predicted dts of the next packet read for this stream or (when there are
-     * several frames in a packet) of the next frame in current packet (in AV_TIME_BASE units) */
-    int64_t       next_dts;
-    ///< dts of the last packet read for this stream (in AV_TIME_BASE units)
-    int64_t       dts;
-
-    int64_t min_pts; /* pts with the smallest value in a current stream */
-    int64_t max_pts; /* pts with the higher value in a current stream */
-
-    /* number of packets successfully read for this stream */
-    uint64_t nb_packets;
-    // combined size of all the packets read
-    uint64_t data_size;
-} DemuxStream;
-
-typedef struct Demuxer {
-    InputFile f;
-
-    // name used for logging
-    char log_name[32];
-
-    int64_t wallclock_start;
-
-    /**
-     * Extra timestamp offset added by discontinuity handling.
-     */
-    int64_t ts_offset_discont;
-    int64_t last_ts;
-
-    /* number of times input stream should be looped */
-    int loop;
-    /* actual duration of the longest stream in a file at the moment when
-     * looping happens */
-    int64_t duration;
-    /* time base of the duration */
-    AVRational time_base;
-
-    /* number of streams that the user was warned of */
-    int nb_streams_warn;
-
-    double readrate_initial_burst;
-
-    AVThreadMessageQueue *in_thread_queue;
-    int                   thread_queue_size;
-    pthread_t             thread;
-    int                   non_blocking;
-
-    int                   read_started;
-} Demuxer;
-
-typedef struct DemuxMsg {
-    AVPacket *pkt;
-    int looping;
-} DemuxMsg;
-
-static DemuxStream *ds_from_ist(InputStream *ist)
-{
-    return (DemuxStream*)ist;
-}
-
 static Demuxer *demuxer_from_ifile(InputFile *f)
 {
     return (Demuxer*)f;
@@ -480,6 +406,48 @@ static int input_packet_process(Demuxer *d, DemuxMsg *msg, AVPacket *src)
     ds->data_size += pkt->size;
     ds->nb_packets++;
 
+    if(pkt->flags & AV_PKT_FLAG_KEY || ist->dec_ctx->codec_id == AV_CODEC_ID_WRAPPED_AVFRAME) {
+        ds->nb_keyframes++;
+
+        if (pkt->dts != AV_NOPTS_VALUE) {
+            int64_t ts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);
+
+            // fps estimation
+            if(ts - ds->last_keyframe_dts > 0) {
+                double framerate = (ds->nb_packets - ds->last_keyframe_pktnb) / (double)(ts - ds->last_keyframe_dts) * (double)AV_TIME_BASE;
+                double gopsize = (double)(ds->nb_packets - ds->last_keyframe_pktnb);
+
+                if(ds->min_framerate == 0.0 || framerate < ds->min_framerate) {
+                    ds->min_framerate = framerate;
+                }
+
+                if(ds->max_framerate == 0.0 || framerate > ds->max_framerate) {
+                    ds->max_framerate = framerate;
+                }
+
+                ds->sum_framerate += framerate;
+
+                if(ds->min_gopsize == 0.0 || gopsize < ds->min_gopsize) {
+                    ds->min_gopsize = gopsize;
+                }
+
+                if(ds->max_gopsize == 0.0 || gopsize > ds->max_gopsize) {
+                    ds->max_gopsize = gopsize;
+                }
+
+                ds->sum_gopsize += gopsize;
+
+                ds->nsamples_average++;
+
+                ds->avg_framerate = ((ds->nsamples_average-1)*ds->avg_framerate + framerate) / (double)ds->nsamples_average;
+                ds->avg_gopsize = ((ds->nsamples_average-1)*ds->avg_gopsize + gopsize) / (double)ds->nsamples_average;
+            }
+
+            ds->last_keyframe_dts = ts;
+            ds->last_keyframe_pktnb = ds->nb_packets;
+        }
+    }
+
     if (debug_ts) {
         av_log(NULL, AV_LOG_INFO, "demuxer+ffmpeg -> ist_index:%d:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s off:%s off_time:%s\n",
                f->index, pkt->stream_index,
diff --git a/fftools/ffmpeg_demux.h b/fftools/ffmpeg_demux.h
new file mode 100644
index 00000000..937f8a22
--- /dev/null
+++ b/fftools/ffmpeg_demux.h
@@ -0,0 +1,121 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <float.h>
+#include <stdint.h>
+
+#include "ffmpeg.h"
+
+#include "libavutil/avassert.h"
+#include "libavutil/avstring.h"
+#include "libavutil/display.h"
+#include "libavutil/error.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/opt.h"
+#include "libavutil/parseutils.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/time.h"
+#include "libavutil/timestamp.h"
+#include "libavutil/thread.h"
+#include "libavutil/threadmessage.h"
+
+#include "libavcodec/packet.h"
+
+#include "libavformat/avformat.h"
+
+typedef struct DemuxStream {
+    InputStream ist;
+
+    // name used for logging
+    char log_name[32];
+
+    double ts_scale;
+
+    int streamcopy_needed;
+
+    int wrap_correction_done;
+    int saw_first_ts;
+    ///< dts of the first packet read for this stream (in AV_TIME_BASE units)
+    int64_t first_dts;
+
+    /* predicted dts of the next packet read for this stream or (when there are
+     * several frames in a packet) of the next frame in current packet (in AV_TIME_BASE units) */
+    int64_t       next_dts;
+    ///< dts of the last packet read for this stream (in AV_TIME_BASE units)
+    int64_t       dts;
+
+    int64_t min_pts; /* pts with the smallest value in a current stream */
+    int64_t max_pts; /* pts with the higher value in a current stream */
+
+    /* number of packets successfully read for this stream */
+    uint64_t nb_packets;
+    uint64_t nb_keyframes;
+    // combined size of all the packets read
+    uint64_t data_size;
+
+    int64_t last_keyframe_dts;
+    int64_t last_keyframe_pktnb;
+    int64_t nsamples_average;
+    double sum_framerate, min_framerate, max_framerate, avg_framerate;
+    double sum_gopsize, min_gopsize, max_gopsize, avg_gopsize;
+} DemuxStream;
+
+typedef struct Demuxer {
+    InputFile f;
+
+    // name used for logging
+    char log_name[32];
+
+    int64_t wallclock_start;
+
+    /**
+     * Extra timestamp offset added by discontinuity handling.
+     */
+    int64_t ts_offset_discont;
+    int64_t last_ts;
+
+    /* number of times input stream should be looped */
+    int loop;
+    /* actual duration of the longest stream in a file at the moment when
+     * looping happens */
+    int64_t duration;
+    /* time base of the duration */
+    AVRational time_base;
+
+    /* number of streams that the user was warned of */
+    int nb_streams_warn;
+
+    double readrate_initial_burst;
+
+    AVThreadMessageQueue *in_thread_queue;
+    int                   thread_queue_size;
+    pthread_t             thread;
+    int                   non_blocking;
+
+    int                   read_started;
+} Demuxer;
+
+typedef struct DemuxMsg {
+    AVPacket *pkt;
+    int looping;
+} DemuxMsg;
+
+static DemuxStream *ds_from_ist(InputStream *ist)
+{
+    return (DemuxStream*)ist;
+}
\ No newline at end of file
diff --git a/fftools/ffmpeg_mux.c b/fftools/ffmpeg_mux.c
index 7a924dba..0617b7f1 100644
--- a/fftools/ffmpeg_mux.c
+++ b/fftools/ffmpeg_mux.c
@@ -31,6 +31,8 @@
 #include "libavutil/log.h"
 #include "libavutil/mem.h"
 #include "libavutil/timestamp.h"
+#include "libavutil/bprint.h"
+#include "libavutil/pixdesc.h"
 #include "libavutil/thread.h"
 
 #include "libavcodec/packet.h"
@@ -135,8 +137,51 @@ static int write_packet(Muxer *mux, OutputStream *ost, AVPacket *pkt)
     ms->last_mux_dts = pkt->dts;
 
     ms->data_size_mux += pkt->size;
+    ms->nb_packets++;
     frame_num = atomic_fetch_add(&ost->packets_written, 1);
 
+    if(pkt->flags & AV_PKT_FLAG_KEY) {
+        ms->nb_keyframes++;
+
+        if (pkt->dts != AV_NOPTS_VALUE) {
+            int64_t ts = av_rescale_q(pkt->dts, ost->st->time_base, AV_TIME_BASE_Q);
+
+            // fps estimation
+            if(ts - ms->last_keyframe_dts > 0) {
+                double framerate = (ms->nb_packets - ms->last_keyframe_pktnb) / (double)(ts - ms->last_keyframe_dts) * (double)AV_TIME_BASE;
+                double gopsize = (double)(ms->nb_packets - ms->last_keyframe_pktnb);
+
+                if(ms->min_framerate == 0.0 || framerate < ms->min_framerate) {
+                    ms->min_framerate = framerate;
+                }
+
+                if(ms->max_framerate == 0.0 || framerate > ms->max_framerate) {
+                    ms->max_framerate = framerate;
+                }
+
+                ms->sum_framerate += framerate;
+
+                if(ms->min_gopsize == 0.0 || gopsize < ms->min_gopsize) {
+                    ms->min_gopsize = gopsize;
+                }
+
+                if(ms->max_gopsize == 0.0 || gopsize > ms->max_gopsize) {
+                    ms->max_gopsize = gopsize;
+                }
+
+                ms->sum_gopsize += gopsize;
+
+                ms->nsamples_average++;
+
+                ms->avg_framerate = ((ms->nsamples_average-1)*ms->avg_framerate + framerate) / (double)ms->nsamples_average;
+                ms->avg_gopsize = ((ms->nsamples_average-1)*ms->avg_gopsize + gopsize) / (double)ms->nsamples_average;
+            }
+
+            ms->last_keyframe_dts = ts;
+            ms->last_keyframe_pktnb = ms->nb_packets;
+        }
+    }
+
     pkt->stream_index = ost->index;
 
     if (debug_ts) {
@@ -587,6 +632,296 @@ fail:
     return ret;
 }
 
+/**
+ * Write a graph as JSON to an initialized buffer
+ *
+ * @param buf Pointer to an initialized AVBPrint buffer
+ * @param graph Pointer to a AVFilterGraph
+ */
+static void print_json_graph(AVBPrint *buf, AVFilterGraph *graph)
+{
+    int i, j;
+
+    if(graph == NULL) {
+        av_bprintf(buf, "null\n");
+        return;
+    }
+
+    av_bprintf(buf, "[");
+
+    for(i = 0; i < graph->nb_filters; i++) {
+        const AVFilterContext *filter_ctx = graph->filters[i];
+
+        for(j = 0; j < filter_ctx->nb_outputs; j++) {
+            AVFilterLink *link = filter_ctx->outputs[j];
+            if(link) {
+                const AVFilterContext *dst_filter_ctx = link->dst;
+
+                av_bprintf(buf,
+                    "{\"src_name\":\"%s\",\"src_filter\":\"%s\",\"dst_name\":\"%s\",\"dst_filter\":\"%s\",",
+                    filter_ctx->name,
+                    filter_ctx->filter->name,
+                    dst_filter_ctx->name,
+                    dst_filter_ctx->filter->name);
+                av_bprintf(buf,
+                    "\"inpad\":\"%s\",\"outpad\":\"%s\",",
+                    avfilter_pad_get_name(link->srcpad, 0),
+                    avfilter_pad_get_name(link->dstpad, 0));
+                av_bprintf(buf,
+                    "\"timebase\": \"%d/%d\",",
+                    link->time_base.num,
+                    link->time_base.den);
+
+                if(link->type == AVMEDIA_TYPE_VIDEO) {
+                    const AVPixFmtDescriptor *desc =
+                        av_pix_fmt_desc_get(link->format);
+                    av_bprintf(buf,
+                        "\"type\":\"video\",\"format\":\"%s\",\"width\":%d,\"height\":%d",
+                        desc->name,
+                        link->w,
+                        link->h);
+                } else if(link->type == AVMEDIA_TYPE_AUDIO) {
+                    char layout[255];
+                    av_channel_layout_describe(&link->ch_layout, layout, sizeof(layout));
+                    av_bprintf(buf,
+                        "\"type\":\"audio\",\"format\":\"%s\",\"sampling_hz\":%d,\"layout\":\"%s\"",
+                        av_get_sample_fmt_name(link->format),
+                        link->sample_rate,
+                        layout);
+                }
+
+                if(i == (graph->nb_filters - 1)) {
+                    av_bprintf(buf, "}");
+                } else {
+                    av_bprintf(buf, "},");
+                }
+            }
+        }
+    }
+
+    av_bprintf(buf, "]");
+}
+
+/**
+ * Print all outputs in JSON format
+ */
+static void print_json_outputs(void)
+{
+    static int ost_all_initialized = 0;
+    int i, j;
+    int nb_output_streams = 0, nb_initialized = 0;
+    AVBPrint buf;
+
+    if(print_jsonstats != 1) {
+        return;
+    }
+
+    if(ost_all_initialized == 1) {
+        return;
+    }
+
+    // count how many outputs are initialized
+    for (OutputStream *ost = ost_iter(NULL); ost; ost = ost_iter(ost)) {
+        nb_output_streams++;
+        if(ost->initialized) {
+            nb_initialized++;
+        }
+    }
+
+    // only when all outputs are initialized, dump the outputs
+    if(nb_initialized == nb_output_streams) {
+        ost_all_initialized = 1;
+    }
+
+    if(ost_all_initialized != 1) {
+        return;
+    }
+
+    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);
+
+    av_bprintf(&buf, "ffmpeg.outputs:[");
+    for (OutputStream *ost = ost_iter(NULL); ost; ost = ost_iter(ost)) {
+        OutputFile *of = output_files[ost->file_index];
+        Muxer *mux = mux_from_of(of);
+        AVFormatContext *ctx = mux->fc;
+        AVStream *st = ost->st;
+        AVDictionaryEntry *lang =
+            av_dict_get(st->metadata, "language", NULL, 0);
+        AVCodecContext *enc = ost->enc_ctx ? ost->enc_ctx : ost->ist->dec_ctx;
+        char *url = NULL;
+
+        fprintf(stderr, "*enc is NULL: %s\n", enc == NULL ? "true" : "false");
+
+        if(av_escape(&url,
+               ctx->url,
+               "\\\"",
+               AV_ESCAPE_MODE_BACKSLASH,
+               AV_UTF8_FLAG_ACCEPT_ALL) < 0) {
+            url = av_strdup("-");
+        }
+
+        av_bprintf(&buf, "{");
+        av_bprintf(&buf,
+            "\"url\":\"%s\",\"format\":\"%s\",\"index\":%d,\"stream\":%d,",
+            url,
+            ctx->oformat->name,
+            ost->file_index,
+            ost->index);
+        av_bprintf(&buf,
+            "\"type\":\"%s\",\"codec\":\"%s\",\"coder\":\"%s\",\"bitrate_kbps\":%" PRId64
+            ",",
+            av_get_media_type_string(enc->codec_type),
+            avcodec_get_name(enc->codec_id),
+            !ost->enc ? "copy"
+                             : (enc->codec ? enc->codec->name : "unknown"),
+            enc->bit_rate / 1000);
+        av_bprintf(&buf,
+            "\"duration_sec\":%f,\"language\":\"%s\",\"profile\":%d,\"level\":%d",
+            0.0,
+            lang != NULL ? lang->value : "und",
+            st->codecpar->profile, st->codecpar->level);
+
+        av_free(url);
+
+        if(enc->codec_type == AVMEDIA_TYPE_VIDEO) {
+            float fps = 0;
+            if(st->avg_frame_rate.den && st->avg_frame_rate.num) {
+                fps = av_q2d(st->avg_frame_rate);
+            }
+
+            av_bprintf(&buf,
+                ",\"fps\":%f,\"pix_fmt\":\"%s\",\"width\":%d,\"height\":%d",
+                fps,
+                st->codecpar->format == AV_PIX_FMT_NONE
+                    ? "none"
+                    : av_get_pix_fmt_name(st->codecpar->format),
+                st->codecpar->width,
+                st->codecpar->height);
+        } else if(enc->codec_type == AVMEDIA_TYPE_AUDIO) {
+            char layout[128];
+            av_channel_layout_describe(&enc->ch_layout, layout, sizeof(layout));
+
+            av_bprintf(&buf,
+                ",\"sampling_hz\":%d,\"layout\":\"%s\",\"channels\":%d",
+                enc->sample_rate,
+                layout,
+                enc->ch_layout.nb_channels);
+        }
+
+        if(ost_iter(ost) == NULL) {
+            av_bprintf(&buf, "}");
+        } else {
+            av_bprintf(&buf, "},");
+        }
+    }
+
+    av_bprintf(&buf, "]");
+
+    fprintf(stderr, "%s\n", buf.str);
+
+    av_bprint_clear(&buf);
+
+    av_bprintf(&buf, "ffmpeg.mapping:{");
+    av_bprintf(&buf, "\"graphs\":[");
+
+    for(i = 0; i < nb_filtergraphs; i++) {
+        av_bprintf(&buf, "{\"index\":%d,\"graph\":", i);
+        print_json_graph(&buf, filtergraphs[i]->graph);
+
+        if(i == (nb_filtergraphs - 1)) {
+            av_bprintf(&buf, "}");
+        } else {
+            av_bprintf(&buf, "},");
+        }
+    }
+
+    av_bprintf(&buf, "],");
+
+    // The following is inspired by tools/graph2dot.c
+
+    av_bprintf(&buf, "\"mapping\":[");
+
+    for (InputStream *ist = ist_iter(NULL); ist; ist = ist_iter(ist)) {
+        for(i = 0; i < ist->nb_filters; i++) {
+            if(ist->filters[i]->graph) {
+                char *name = NULL;
+                AVFilterGraph *fg = ist->filters[i]->graph->graph;
+                for(j = 0; j < fg->nb_filters; j++) {
+                    AVFilterContext *ctx = fg->filters[j];
+                    if(ctx->nb_inputs == 0) { // if there are no input links, then this is the first filter in the chain
+                        name = ctx->name;
+                        break;
+                    }
+                }
+
+                av_bprintf(&buf,
+                    "{\"input\":{\"index\":%d,\"stream\":%d},\"graph\":{\"index\":%d,\"name\":\"%s\"},\"output\":null},",
+                    ist->file_index,
+                    ist->st->index,
+                    ist->filters[i]->graph->index,
+                    name);
+            }
+        }
+    }
+
+    for (OutputStream *ost = ost_iter(NULL); ost; ost = ost_iter(ost)) {
+        if(ost->attachment_filename) {
+            av_bprintf(&buf,
+                "{\"input\":null,\"file\":\"%s\",\"output\":{\"index\":%d,\"stream\":%d}},",
+                ost->attachment_filename,
+                ost->file_index,
+                ost->index);
+            goto next_output;
+        }
+
+        if(ost->filter && ost->filter->graph) {
+            char *name = NULL;
+            AVFilterGraph *fg = ost->filter->graph->graph;
+            for(j = 0; j < fg->nb_filters; j++) {
+                AVFilterContext *ctx = fg->filters[j];
+                if(ctx->nb_outputs == 0) { // if there are no output links, then this is the last filter in the chain
+                    name = ctx->name;
+                    break;
+                }
+            }
+
+            av_bprintf(&buf,
+                "{\"input\":null,\"graph\":{\"index\":%d,\"name\":\"%s\"},\"output\":{\"index\":%d,\"stream\":%d}}",
+                ost->filter->graph->index,
+                name,
+                ost->file_index,
+                ost->index);
+            goto next_output;
+        }
+
+        if(ost->ist) {
+            av_bprintf(&buf,
+                "{\"input\":{\"index\":%d,\"stream\":%d},\"output\":{\"index\":%d,\"stream\":%d}",
+                ost->ist->file_index,
+                ost->ist->st->index,
+                ost->file_index,
+                ost->index);
+            av_bprintf(&buf, ",\"copy\":%s", !ost->enc ? "true" : "false");
+        }
+
+        av_bprintf(&buf, "}");
+
+    next_output:
+        if(ost_iter(ost) != NULL) {
+            av_bprintf(&buf, ",");
+        }
+    }
+
+    av_bprintf(&buf, "]}");
+
+    fprintf(stderr, "%s\n", buf.str);
+    fflush(stderr);
+
+    av_bprint_finalize(&buf, NULL);
+
+    return;
+}
+
 int mux_check_init(Muxer *mux)
 {
     OutputFile *of = &mux->of;
@@ -611,6 +946,8 @@ int mux_check_init(Muxer *mux)
     av_dump_format(fc, of->index, fc->url, 1);
     nb_output_dumped++;
 
+    print_json_outputs();
+
     if (sdp_filename || want_sdp) {
         ret = print_sdp();
         if (ret < 0) {
diff --git a/fftools/ffmpeg_mux.h b/fftools/ffmpeg_mux.h
index a2bb4dfc..11a726b9 100644
--- a/fftools/ffmpeg_mux.h
+++ b/fftools/ffmpeg_mux.h
@@ -84,6 +84,18 @@ typedef struct MuxStream {
     int copy_initial_nonkeyframes;
     int copy_prior_start;
     int streamcopy_started;
+
+    uint64_t nb_packets;
+    uint64_t nb_keyframes;
+    // number of frames/samples sent to the encoder
+    uint64_t frames_encoded;
+    uint64_t samples_encoded;
+
+    int64_t last_keyframe_dts;
+    int64_t last_keyframe_pktnb;
+    int64_t nsamples_average;
+    double sum_framerate, min_framerate, max_framerate, avg_framerate;
+    double sum_gopsize, min_gopsize, max_gopsize, avg_gopsize;
 } MuxStream;
 
 typedef struct Muxer {
diff --git a/fftools/ffmpeg_opt.c b/fftools/ffmpeg_opt.c
index 304471dd..5dee17be 100644
--- a/fftools/ffmpeg_opt.c
+++ b/fftools/ffmpeg_opt.c
@@ -52,6 +52,7 @@
 #include "libavutil/parseutils.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/pixfmt.h"
+#include "libavutil/bprint.h"
 
 const char *const opt_name_codec_names[]                      = {"c", "codec", "acodec", "vcodec", "scodec", "dcodec", NULL};
 const char *const opt_name_frame_rates[]                      = {"r", NULL};
@@ -82,6 +83,7 @@ int debug_ts          = 0;
 int exit_on_error     = 0;
 int abort_on_flags    = 0;
 int print_stats       = -1;
+int print_jsonstats   = 1;
 int stdin_interaction = 1;
 float max_error_rate  = 2.0/3;
 char *filter_nbthreads;
@@ -1296,6 +1298,112 @@ static int open_files(OptionGroupList *l, const char *inout,
     return 0;
 }
 
+/**
+ * Print all inputs in JSON format
+ */
+static void print_json_inputs(void)
+{
+    AVBPrint buf;
+    int i, j;
+
+    if(print_jsonstats != 1) {
+        return;
+    }
+
+    av_bprint_init(&buf, 0, AV_BPRINT_SIZE_UNLIMITED);
+
+    av_bprintf(&buf, "ffmpeg.inputs:[");
+    for(i = 0; i < nb_input_files; i++) {
+        InputFile *f = input_files[i];
+        AVFormatContext *ctx = f->ctx;
+
+        float duration = 0;
+        if(ctx->duration != AV_NOPTS_VALUE) {
+            duration = (float)(ctx->duration +
+                           (ctx->duration <= INT64_MAX - 5000 ? 5000 : 0)) /
+                (float)AV_TIME_BASE;
+        }
+
+        for(j = 0; j < f->nb_streams; j++) {
+            InputStream *ist = f->streams[j];
+            AVCodecContext *dec = ist->dec_ctx;
+            AVStream *st = ist->st;
+            AVDictionaryEntry *lang =
+                av_dict_get(st->metadata, "language", NULL, 0);
+            char *url = NULL;
+
+            if(av_escape(&url,
+                   ctx->url,
+                   "\\\"",
+                   AV_ESCAPE_MODE_BACKSLASH,
+                   AV_UTF8_FLAG_ACCEPT_ALL) < 0) {
+                url = av_strdup("-");
+            }
+
+            av_bprintf(&buf, "{");
+            av_bprintf(&buf,
+                "\"url\":\"%s\",\"format\":\"%s\",\"index\":%d,\"stream\":%d,",
+                url,
+                ctx->iformat->name,
+                ist->file_index,
+                ist->index);
+            av_bprintf(&buf,
+                "\"type\":\"%s\",\"codec\":\"%s\",\"coder\":\"%s\",\"bitrate_kbps\":%" PRId64
+                ",",
+                av_get_media_type_string(dec->codec_type),
+                avcodec_get_name(dec->codec_id),
+                dec->codec ? dec->codec->name : "unknown",
+                dec->bit_rate / 1000);
+            av_bprintf(&buf,
+                "\"duration_sec\":%f,\"language\":\"%s\",\"profile\":%d,\"level\":%d",
+                duration,
+                lang != NULL ? lang->value : "und",
+                st->codecpar->profile, st->codecpar->level);
+
+            av_free(url);
+
+            if(dec->codec_type == AVMEDIA_TYPE_VIDEO) {
+                float fps = 0;
+                if(st->avg_frame_rate.den && st->avg_frame_rate.num) {
+                    fps = av_q2d(st->avg_frame_rate);
+                }
+
+                av_bprintf(&buf,
+                    ",\"fps\":%f,\"pix_fmt\":\"%s\",\"width\":%d,\"height\":%d",
+                    fps,
+                    st->codecpar->format == AV_PIX_FMT_NONE
+                        ? "none"
+                        : av_get_pix_fmt_name(st->codecpar->format),
+                    st->codecpar->width,
+                    st->codecpar->height);
+            } else if(dec->codec_type == AVMEDIA_TYPE_AUDIO) {
+                char layout[128];
+
+                av_channel_layout_describe(&dec->ch_layout, layout, sizeof(layout));
+
+                av_bprintf(&buf,
+                    ",\"sampling_hz\":%d,\"layout\":\"%s\",\"channels\":%d",
+                    dec->sample_rate,
+                    layout,
+                    dec->ch_layout.nb_channels);
+            }
+
+            if(i == (nb_input_files - 1) && j == (f->nb_streams - 1)) {
+                av_bprintf(&buf, "}");
+            } else {
+                av_bprintf(&buf, "},");
+            }
+        }
+    }
+
+    av_bprintf(&buf, "]");
+
+    fprintf(stderr, "%s\n", buf.str);
+    fflush(stderr);
+
+    av_bprint_finalize(&buf, NULL);
+}
+
 int ffmpeg_parse_options(int argc, char **argv)
 {
     OptionParseContext octx;
@@ -1329,6 +1437,8 @@ int ffmpeg_parse_options(int argc, char **argv)
         goto fail;
     }
 
+    print_json_inputs();
+
     /* create the complex filtergraphs */
     ret = init_complex_filters();
     if (ret < 0) {
@@ -1591,6 +1701,8 @@ const OptionDef options[] = {
         "enable automatic conversion filters globally" },
     { "stats",          OPT_BOOL,                                    { &print_stats },
         "print progress report during encoding", },
+    { "jsonstats",      OPT_BOOL,                                    { &print_jsonstats },
+        "print JSON progress report during encoding", },
     { "stats_period",    HAS_ARG | OPT_EXPERT,                       { .func_arg = opt_stats_period },
         "set the period at which ffmpeg updates stats and -progress output", "time" },
     { "attach",         HAS_ARG | OPT_PERFILE | OPT_EXPERT |

base-commit: 8cda858db538d0c09cafcdfd68939da4d19f0175
-- 
2.39.3 (Apple Git-145)

